<!DOCTYPE html>
<html lang="ru" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мем-генератор PRO</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            --background: 0 0% 100%;
            --foreground: 222.2 84% 4.9%;
            --card: 0 0% 100%;
            --card-foreground: 222.2 84% 4.9%;
            --popover: 0 0% 100%;
            --popover-foreground: 222.2 84% 4.9%;
            --primary: 221.2 83.2% 53.3%;
            --primary-foreground: 210 40% 98%;
            --secondary: 210 40% 96.1%;
            --secondary-foreground: 222.2 47.4% 11.2%;
            --muted: 210 40% 96.1%;
            --muted-foreground: 215.4 16.3% 46.9%;
            --accent: 210 40% 96.1%;
            --accent-foreground: 222.2 47.4% 11.2%;
            --destructive: 0 84.2% 60.2%;
            --destructive-foreground: 210 40% 98%;
            --border: 214.3 31.8% 91.4%;
            --input: 214.3 31.8% 91.4%;
            --ring: 221.2 83.2% 53.3%;
            --radius: 0.5rem;
        }
        
        .dark {
            --background: 222.2 84% 4.9%;
            --foreground: 210 40% 98%;
            --card: 222.2 84% 4.9%;
            --card-foreground: 210 40% 98%;
            --popover: 222.2 84% 4.9%;
            --popover-foreground: 210 40% 98%;
            --primary: 217.2 91.2% 59.8%;
            --primary-foreground: 222.2 47.4% 11.2%;
            --secondary: 217.2 32.6% 17.5%;
            --secondary-foreground: 210 40% 98%;
            --muted: 217.2 32.6% 17.5%;
            --muted-foreground: 215 20.2% 65.1%;
            --accent: 217.2 32.6% 17.5%;
            --accent-foreground: 210 40% 98%;
            --destructive: 0 62.8% 30.6%;
            --destructive-foreground: 210 40% 98%;
            --border: 217.2 32.6% 17.5%;
            --input: 217.2 32.6% 17.5%;
            --ring: 224.3 76.3% 48%;
        }
        
        * {
            font-family: 'Inter', sans-serif;
        }
        
        body {
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            transition: background-color 0.3s;
        }
        
        .border-border {
            border-color: hsl(var(--border));
        }
        
        .bg-card {
            background-color: hsl(var(--card));
        }
        
        .text-card-foreground {
            color: hsl(var(--card-foreground));
        }
        
        .bg-primary {
            background-color: hsl(var(--primary));
        }
        
        .text-primary-foreground {
            color: hsl(var(--primary-foreground));
        }
        
        .bg-secondary {
            background-color: hsl(var(--secondary));
        }
        
        .text-secondary-foreground {
            color: hsl(var(--secondary-foreground));
        }
        
        .bg-muted {
            background-color: hsl(var(--muted));
        }
        
        .text-muted-foreground {
            color: hsl(var(--muted-foreground));
        }
        
        .bg-accent {
            background-color: hsl(var(--accent));
        }
        
        .text-accent-foreground {
            color: hsl(var(--accent-foreground));
        }
        
        .bg-destructive {
            background-color: hsl(var(--destructive));
        }
        
        .text-destructive-foreground {
            color: hsl(var(--destructive-foreground));
        }
        
        .border-input {
            border-color: hsl(var(--input));
        }
        
        .ring-ring {
            --tw-ring-color: hsl(var(--ring));
        }
        .w-full{
            background: transparent;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        
        .text-wrap-balance {
            text-wrap: balance;
        }
        
        .multi-line-text {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-width: 100%;
        }
        .grid {
            display: grid;
        }
        .grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        .grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        .grid-cols-5 { grid-template-columns: repeat(5, minmax(0, 1fr)); }
        .grid-cols-6 { grid-template-columns: repeat(6, minmax(0, 1fr)); }
        
        /* Анимации */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .animate-fadeIn {
            animation: fadeIn 0.3s ease-out;
        }
        
        /* Стили для шаблонов */
        .template-item {
            transition: all 0.2s ease;
        }
        
        .template-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        
        /* Стили для слайдера */
        .slider-track {
            height: 6px;
            background-color: hsl(var(--muted));
            border-radius: 3px;
        }
        
        .slider-thumb {
            width: 20px;
            height: 20px;
            background-color: hsl(var(--primary));
            border-radius: 50%;
            border: 2px solid hsl(var(--background));
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        
        /* Стили для сетки изображений */
        .cat-grid-item {
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .cat-grid-item:hover {
            transform: scale(1.03);
        }
        
        .cat-grid-item.selected {
            outline: 3px solid hsl(var(--primary));
            outline-offset: -3px;
        }
        
        /* Стили для слайдера предпросмотра */
        .preview-slider {
            position: relative;
            overflow: hidden;
        }
        
        .preview-slide {
            transition: transform 0.5s ease;
        }
        
        .preview-nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background-color: hsl(var(--background)/0.8);
            backdrop-filter: blur(4px);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 1px solid hsl(var(--border));
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .preview-nav-btn:hover {
            background-color: hsl(var(--accent));
        }
        
        .preview-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 16px;
        }
        
        .preview-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: hsl(var(--muted));
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .preview-dot.active {
            background-color: hsl(var(--primary));
        }
        
        /* Фиксированная панель действий */
        .sticky-actions {
            position: sticky;
            top: 0;
            z-index: 50;
            backdrop-filter: blur(8px);
            background-color: hsl(var(--background)/0.8);
            border-bottom: 1px solid hsl(var(--border));
        }
        
        /* Стили для сетки предпросмотра */
        .preview-grid-view {
            display: grid;
            gap: 16px;
            padding: 16px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .preview-grid-item {
            background: hsl(var(--card));
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }
        
        .preview-grid-item:hover {
            transform: translateY(-2px);
        }
        
        .preview-grid-canvas {
            width: 100%;
            height: 200px;
            object-fit: contain;
            background: hsl(var(--muted));
        }
        
        .preview-grid-info {
            padding: 12px;
            font-size: 0.875rem;
        }
        
        /* Переключатель режима просмотра */
        .view-toggle {
            display: flex;
            gap: 4px;
            background: hsl(var(--muted));
            padding: 4px;
            border-radius: 6px;
        }
        
        .view-toggle-btn {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            background: transparent;
            color: hsl(var(--muted-foreground));
        }
        
        .view-toggle-btn.active {
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }
    </style>
</head>
<body class="min-h-screen bg-background text-foreground">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <!-- Заголовок -->
        <header class="mb-10 text-center">
            <h1 class="text-4xl font-bold tracking-tight mb-3 bg-gradient-to-r from-primary to-purple-600 bg-clip-text text-transparent">
                Мем-генератор PRO
            </h1>
            <p class="text-muted-foreground text-lg max-w-3xl mx-auto">
                Создавайте мемы с расширенными функциями: библиотека котов, шаблоны, пакетное редактирование
            </p>
        </header>
        
        <!-- Вкладки -->
        <div class="mb-8">
            <div class="flex space-x-2 border-b border-border">
                <button id="tab-meme" class="tab-btn px-4 py-3 font-medium text-sm relative data-[active=true]:text-primary data-[active=true]:after:absolute data-[active=true]:after:bottom-0 data-[active=true]:after:left-0 data-[active=true]:after:w-full data-[active=true]:after:h-0.5 data-[active=true]:after:bg-primary" data-active="true">
                    <i class="fas fa-magic mr-2"></i> Мем-генератор
                </button>
                <button id="tab-cats" class="tab-btn px-4 py-3 font-medium text-sm relative data-[active=false]:text-muted-foreground data-[active=true]:text-primary data-[active=true]:after:absolute data-[active=true]:after:bottom-0 data-[active=true]:after:left-0 data-[active=true]:after:w-full data-[active=true]:after:h-0.5 data-[active=true]:after:bg-primary" data-active="false">
                    <i class="fas fa-cat mr-2"></i> Библиотека кисок
                </button>
                <button id="tab-templates" class="tab-btn px-4 py-3 font-medium text-sm relative data-[active=false]:text-muted-foreground data-[active=true]:text-primary data-[active=true]:after:absolute data-[active=true]:after:bottom-0 data-[active=true]:after:left-0 data-[active=true]:after:w-full data-[active=true]:after:h-0.5 data-[active=true]:after:bg-primary" data-active="false">
                    <i class="fas fa-save mr-2"></i> Мои шаблоны
                </button>
            </div>
        </div>
        
        <!-- Контент вкладки Мем-генератор -->
        <div id="content-meme" class="tab-content active animate-fadeIn">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <!-- Левая панель: настройки -->
                <div class="lg:col-span-1 space-y-6">
                    <div class="bg-card rounded-xl border border-border p-6 shadow-sm">
                        <h2 class="text-xl font-semibold mb-6 flex items-center">
                            <i class="fas fa-sliders-h mr-3 text-primary"></i> Настройки мема
                        </h2>
                        
                        <!-- Источник изображения -->
                        <div class="space-y-4">
                            <div>
                                <label class="text-sm font-medium mb-2 block">Источник изображения</label>
                                <div class="grid grid-cols-2 gap-2">
                                    <button id="source-upload" class="source-btn px-4 py-3 text-sm font-medium rounded-lg border border-input bg-background hover:bg-accent data-[active=true]:bg-primary data-[active=true]:text-primary-foreground data-[active=true]:border-primary" data-active="true">
                                        <i class="fas fa-upload mr-2"></i> Загрузить
                                    </button>
                                    <button id="source-library" class="source-btn px-4 py-3 text-sm font-medium rounded-lg border border-input bg-background hover:bg-accent data-[active=false]:text-muted-foreground data-[active=true]:bg-primary data-[active=true]:text-primary-foreground data-[active=true]:border-primary" data-active="false">
                                        <i class="fas fa-cat mr-2"></i> Библиотека
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Загрузка файлов -->
                            <div id="upload-section">
                                <label class="text-sm font-medium mb-2 block">Загрузить изображения</label>
                                <div class="border-2 border-dashed border-input rounded-lg p-6 text-center hover:border-primary transition-colors cursor-pointer" id="drop-zone">
                                    <i class="fas fa-cloud-upload-alt text-3xl text-muted-foreground mb-3"></i>
                                    <p class="text-sm font-medium mb-1">Перетащите изображения сюда</p>
                                    <p class="text-xs text-muted-foreground mb-4">или нажмите для выбора файлов</p>
                                    <input type="file" id="file-input" class="hidden" multiple accept="image/*">
                                    <button id="browse-btn" class="px-4 py-2 text-sm font-medium rounded-md bg-primary text-primary-foreground hover:bg-primary/90">
                                        Выбрать файлы
                                    </button>
                                    <p class="text-xs text-muted-foreground mt-3">Можно выбрать несколько файлов (Shift+клик)</p>
                                </div>
                                <div id="file-list" class="mt-3 space-y-2 max-h-40 overflow-y-auto scrollbar-hide"></div>
                            </div>
                            
                            <!-- Библиотека -->
                            <div id="library-section" class="hidden">
                                <label class="text-sm font-medium mb-2 block">Выбрать из библиотеки</label>
                                <p class="text-sm text-muted-foreground mb-4">Перейдите во вкладку "Библиотека кисок" для выбора изображений</p>
                                <button id="goto-library-btn" class="w-full px-4 py-3 text-sm font-medium rounded-lg border border-input bg-background hover:bg-accent">
                                    <i class="fas fa-external-link-alt mr-2"></i> Перейти в библиотеку
                                </button>
                            </div>
                        </div>
                        
                        <!-- Формат изображения -->
                        <div class="mt-6">
                            <label class="text-sm font-medium mb-2 block">Формат изображения</label>
  <select id="image-format" class="w-full px-3 py-2 text-sm rounded-lg border border-input bg-background focus:outline-none focus:ring-2 focus:ring-primary">
    <option value="original">Оригинальный</option>
    <option value="square">Квадрат (1:1)</option>
    
    <option value="standard">Стандартный (4:3)</option>
    <option value="classic">Классика фото (3:2)</option>
    <option value="wide">Широкий (16:9)</option>
    <option value="cinematic">Кино (21:9)</option>
    
    <option value="insta-portrait">Инста-портрет (4:5)</option>
    <option value="portrait">Портрет (9:16)</option>
</select>
                        </div>
                        
                        <!-- Тексты -->
                        <div class="mt-6 space-y-4">
                            <div>
                                <label class="text-sm font-medium mb-2 block">Текст сверху</label>
                                <textarea id="top-text" rows="2" class="w-full px-3 py-2 text-sm rounded-lg border border-input bg-background focus:outline-none focus:ring-2 focus:ring-ring resize-none" placeholder="Введите текст для верхней части мема"></textarea>
                                <p class="text-xs text-muted-foreground mt-1">Поддерживает перенос строки (Enter)</p>
                            </div>
                            <div>
                                <label class="text-sm font-medium mb-2 block">Текст снизу</label>
                                <textarea id="bottom-text" rows="2" class="w-full px-3 py-2 text-sm rounded-lg border border-input bg-background focus:outline-none focus:ring-2 focus:ring-ring resize-none" placeholder="Введите текст для нижней части мема"></textarea>
                                <p class="text-xs text-muted-foreground mt-1">Поддерживает перенос строки (Enter)</p>
                            </div>
                        </div>
                        
                        <!-- Растяжение -->
                        <div class="mt-6 space-y-5">
                            <div>
                                <div class="flex justify-between mb-2">
                                    <label class="text-sm font-medium">Растяжение по горизонтали</label>
                                    <span id="stretch-x-value" class="text-sm font-medium">1.0</span>
                                </div>
                                <div class="relative pt-1">
                                    <div class="slider-track">
                                        <div id="stretch-x-track" class="h-full rounded bg-primary" style="width: 50%"></div>
                                    </div>
                                    <input type="range" id="stretch-x" min="0.5" max="2" step="0.1" value="1" class="absolute top-0 left-0 w-full h-full opacity-0 cursor-pointer">
                                </div>
                            </div>
                            
                            <div>
                                <div class="flex justify-between mb-2">
                                    <label class="text-sm font-medium">Растяжение по вертикали</label>
                                    <span id="stretch-y-value" class="text-sm font-medium">1.0</span>
                                </div>
                                <div class="relative pt-1">
                                    <div class="slider-track">
                                        <div id="stretch-y-track" class="h-full rounded bg-primary" style="width: 50%"></div>
                                    </div>
                                    <input type="range" id="stretch-y" min="0.5" max="2" step="0.1" value="1" class="absolute top-0 left-0 w-full h-full opacity-0 cursor-pointer">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Искажение -->
                        <div class="mt-6">
                            <label class="text-sm font-medium mb-2 block">Направление искажения</label>
                            <div class="grid grid-cols-2 gap-2">
                                <button id="distort-horizontal" class="distort-btn px-4 py-3 text-sm font-medium rounded-lg border border-input bg-background hover:bg-accent data-[active=true]:bg-primary data-[active=true]:text-primary-foreground data-[active=true]:border-primary" data-active="true">
                                    <i class="fas fa-arrows-alt-h mr-2"></i> Горизонтально
                                </button>
                                <button id="distort-vertical" class="distort-btn px-4 py-3 text-sm font-medium rounded-lg border border-input bg-background hover:bg-accent data-[active=false]:text-muted-foreground data-[active=true]:bg-primary data-[active=true]:text-primary-foreground data-[active=true]:border-primary" data-active="false">
                                    <i class="fas fa-arrows-alt-v mr-2"></i> Вертикально
                                </button>
                            </div>
                        </div>
                        
                        <!-- Красный фильтр -->
                        <div class="mt-6">
                            <div class="flex justify-between mb-2">
                                <label class="text-sm font-medium">Красный фильтр</label>
                                <span id="red-filter-value" class="text-sm font-medium">0%</span>
                            </div>
                            <div class="relative pt-1">
                                <div class="slider-track">
                                    <div id="red-filter-track" class="h-full rounded bg-red-500" style="width: 0%"></div>
                                </div>
                                <input type="range" id="red-filter" min="0" max="100" step="1" value="0" class="absolute top-0 left-0 w-full h-full opacity-0 cursor-pointer">
                            </div>
                        </div>
                        
                        <!-- Сохранение шаблона -->
                        <div class="mt-8 pt-6 border-t border-border">
                            <label class="text-sm font-medium mb-2 block">Шаблоны</label>
                            <div class="flex gap-2">
                                <input type="text" id="template-name" placeholder="Название шаблона" class="flex-1 px-3 py-2 text-sm rounded-lg border border-input bg-background focus:outline-none focus:ring-2 focus:ring-ring">
                                <button id="save-template" class="px-4 py-2 text-sm font-medium rounded-lg bg-primary text-primary-foreground hover:bg-primary/90">
                                    <i class="fas fa-save mr-1"></i> Сохранить
                                </button>
                            </div>
                            <p class="text-xs text-muted-foreground mt-2">Сохраните текущие настройки как шаблон</p>
                        </div>
                    </div>
                    
                    <!-- Быстрые действия -->
                    <div class="bg-card rounded-xl border border-border p-6 shadow-sm">
                        <h3 class="text-lg font-semibold mb-4">Быстрые действия</h3>
                        <div class="grid grid-cols-2 gap-3">
                            <button id="download-meme" class="px-4 py-3 text-sm font-medium rounded-lg bg-primary text-primary-foreground hover:bg-primary/90 flex items-center justify-center">
                                <i class="fas fa-download mr-2"></i> Скачать все
                            </button>
                            <button id="reset-all" class="px-4 py-3 text-sm font-medium rounded-lg border border-input bg-background hover:bg-accent flex items-center justify-center">
                                <i class="fas fa-redo mr-2"></i> Сбросить
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Правая панель: предпросмотр -->
                <div class="lg:col-span-2">
                    <div class="bg-card rounded-xl border border-border p-6 shadow-sm h-full">
                        <div class="flex justify-between items-center mb-6">
                            <div>
                                <h2 class="text-xl font-semibold flex items-center">
                                    <i class="fas fa-eye mr-3 text-primary"></i> Предпросмотр
                                </h2>
                                <div class="mt-2 flex items-center gap-4">
                                    <div class="view-toggle">
                                        <button id="view-slider" class="view-toggle-btn active" data-view="slider">
                                            <i class="fas fa-images mr-1"></i> Слайдер
                                        </button>
                                        <button id="view-grid" class="view-toggle-btn" data-view="grid">
                                            <i class="fas fa-th-large mr-1"></i> Сетка
                                        </button>
                                    </div>
                                    <div class="flex items-center text-sm">
                                        <span id="current-slide" class="font-medium">1</span>
                                        <span class="mx-2">/</span>
                                        <span id="total-slides" class="font-medium">1</span>
                                    </div>
                                </div>
                            </div>
                            <button id="apply-to-all" class="px-4 py-2 text-sm font-medium rounded-lg border border-input bg-background hover:bg-accent hidden">
                                <i class="fas fa-copy mr-1"></i> Применить ко всем
                            </button>
                        </div>
                        
                        <!-- Слайдер предпросмотра -->
                        <div id="slider-view" class="preview-slider relative rounded-lg overflow-hidden bg-muted min-h-[400px] flex items-center justify-center">
                            <!-- Навигация слайдера -->
                            <button id="prev-slide" class="preview-nav-btn left-4 hidden">
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <button id="next-slide" class="preview-nav-btn right-4 hidden">
                                <i class="fas fa-chevron-right"></i>
                            </button>
                            
                            <!-- Контейнер слайдов -->
                            <div id="slides-container" class="w-full h-full flex transition-transform duration-300">
                                <!-- Слайды будут добавлены через JS -->
                                <div class="preview-slide min-w-full flex items-center justify-center p-4">
                                    <canvas id="meme-canvas" class="max-w-full max-h-[350px] bg-background rounded-lg shadow-lg"></canvas>
                                </div>
                            </div>
                            
                            <!-- Сообщение при отсутствии изображений -->
                            <div id="no-images-message" class="absolute inset-0 flex flex-col items-center justify-center p-8 text-center">
                                <i class="fas fa-image text-5xl text-muted-foreground mb-4"></i>
                                <h3 class="text-xl font-medium mb-2">Нет изображений для отображения</h3>
                                <p class="text-muted-foreground">Загрузите изображения или выберите их из библиотеки</p>
                            </div>
                        </div>
                        
                        <!-- Сетка предпросмотра -->
                        <div id="grid-view" class="hidden">
                            <div class="preview-grid-view grid-cols-1 sm:grid-cols-2 lg:grid-cols-3" id="grid-container">
                                <!-- Сетка будет заполнена через JS -->
                            </div>
                        </div>
                        
                        <!-- Точки навигации -->
                        <div id="preview-dots" class="preview-dots mt-6"></div>
                        
                        <!-- Информация о текущем слайде -->
                        <div class="mt-6 p-4 rounded-lg bg-muted">
                            <div class="flex items-center justify-between">
                                <div>
                                    <p class="text-sm font-medium">Текущее изображение</p>
                                    <p id="current-image-name" class="text-sm text-muted-foreground">Нет изображения</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Статус многократного редактирования -->
                        <div id="batch-status" class="mt-4 p-3 rounded-lg bg-primary/10 border border-primary/20 hidden">
                            <div class="flex items-center">
                                <i class="fas fa-layer-group text-primary mr-3"></i>
                                <div class="flex-1">
                                    <p class="text-sm font-medium">Режим пакетного редактирования</p>
                                    <p id="batch-count" class="text-xs text-muted-foreground">Обрабатывается 1 изображение</p>
                                </div>
                                <button id="clear-batch" class="text-xs px-3 py-1 rounded bg-background border border-input hover:bg-accent">
                                    Очистить
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Контент вкладки Библиотека кисок -->
        <div id="content-cats" class="tab-content hidden">
            <!-- Фиксированная панель действий -->
            <div class="sticky-actions -mx-4 px-4 py-4 mb-6 -mt-8">
                <div class="flex flex-wrap items-center justify-between gap-4">
                    <div>
                        <h2 class="text-xl font-semibold flex items-center">
                            <i class="fas fa-cat mr-3 text-primary"></i> Библиотека кисок
                        </h2>
                        <div class="mr-3">
    <select id="api-source" class="w-full px-3 py-1.5 text-sm border border-input rounded-lg bg-background focus:outline-none focus:ring-2 focus:ring-primary">
        <option value="thecatapi">The Cat API (Случайные)</option>
        <option value="cataas">CATAAS (Поиск по тегам)</option>
    </select>
</div>
                        <div class="mt-2 relative w-full max-w-xs">
                            <i class="fas fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground text-xs"></i>
                            <input type="text" id="cat-search" placeholder="Найти котика..." class="w-full pl-9 pr-4 py-1.5 text-sm border border-input rounded-lg bg-background focus:outline-none focus:ring-2 focus:ring-primary">
                        </div>
                    </div>
                    
                    <div class="flex flex-wrap gap-3">
                        <!-- Размер сетки -->
                        <div class="flex items-center gap-3">
                            <span class="text-sm font-medium">Размер сетки:</span>
                            <div class="flex items-center gap-2 w-32">
                                <div class="relative pt-1 flex-1">
                                    <div class="slider-track">
                                        <div id="grid-size-track" class="h-full rounded bg-primary" style="width: 50%"></div>
                                    </div>
                                    <input type="range" id="grid-size-slider" min="2" max="6" step="1" value="4" class="absolute top-0 left-0 w-full h-full opacity-0 cursor-pointer">
                                </div>
                                <span id="grid-size-value" class="text-sm font-medium min-w-8 text-center">4</span>
                            </div>
                        </div>
                        
                        <!-- Действия -->
                        <div class="flex items-center gap-3">
                            <!-- <button id="select-all-cats" class="px-4 py-2 text-sm font-medium rounded-lg border border-input bg-background hover:bg-accent">
                                <i class="fas fa-check-double mr-1"></i> Выбрать все
                            </button> -->
                            <button id="clear-selection-cats" class="px-4 py-2 text-sm font-medium rounded-lg border border-input bg-background hover:bg-accent">
                                <i class="fas fa-times mr-1"></i> Очистить
                            </button>
                            <button id="use-selected-in-meme" class="px-4 py-2 text-sm font-medium rounded-lg bg-primary text-primary-foreground hover:bg-primary/90">
                                <i class="fas fa-magic mr-1"></i> Использовать
                            </button>
                            <button id="download-selected-cats" class="px-4 py-2 text-sm font-medium rounded-lg bg-primary text-primary-foreground hover:bg-primary/90">
                                <i class="fas fa-download mr-1"></i> Скачать
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Статус выделения -->
                <div class="mt-4">
                    <div class="flex items-center justify-between">
                        <p class="text-sm">
                            Выделено: <span id="selected-count" class="font-semibold">0</span> изображений
                            <span class="text-muted-foreground ml-2">(Используйте Shift для выделения диапазона)</span>
                        </p>
                        <button id="goto-meme-from-cats" class="text-sm px-3 py-1 rounded-lg border border-input bg-background hover:bg-accent">
                            <i class="fas fa-arrow-left mr-1"></i> Вернуться в редактор
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Сетка изображений -->
            <div id="cats-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 mt-8">
                <!-- Котики будут загружены через JS -->
            </div>
            
            <!-- Пагинация (заглушка) -->
            <div id="scroll-sentinel" class="w-full py-8 flex justify-center items-center">
                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
                <span class="ml-3 text-muted-foreground text-sm">Ищем котиков...</span>
            </div>
        </div>
        
        <!-- Контент вкладки Мои шаблоны -->
        <div id="content-templates" class="tab-content hidden">
            <div class="bg-card rounded-xl border border-border p-6 shadow-sm">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-semibold flex items-center">
                        <i class="fas fa-save mr-3 text-primary"></i> Мои шаблоны
                    </h2>
                    <button id="goto-meme-from-templates" class="px-4 py-2 text-sm font-medium rounded-lg border border-input bg-background hover:bg-accent">
                        <i class="fas fa-arrow-left mr-1"></i> Вернуться в редактор
                    </button>
                </div>
                
                <!-- Сообщение при отсутствии шаблонов -->
                <div id="no-templates-message" class="text-center py-12">
                    <i class="fas fa-save text-5xl text-muted-foreground mb-4"></i>
                    <h3 class="text-xl font-medium mb-2">У вас пока нет сохраненных шаблонов</h3>
                    <p class="text-muted-foreground mb-6 max-w-md mx-auto">
                        Сохраняйте настройки мемов как шаблоны, чтобы быстро применять их к новым изображениям
                    </p>
                </div>
                
                <!-- Сетка шаблонов -->
                <div id="templates-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Шаблоны будут добавлены через JS -->
                </div>
            </div>
        </div>
        
        <!-- Футер -->
        <footer class="mt-12 pt-8 border-t border-border text-center">
            <p class="text-muted-foreground text-sm">
                Мем-генератор PRO &copy; 2023 | Создавайте мемы с расширенными функциями
            </p>
        </footer>
    </div>

 <script>
    // Инициализация приложения
    document.addEventListener('DOMContentLoaded', function() {
        // Основные переменные
        const state = {
            currentTab: 'meme',
            currentApi: 'thecatapi',
            images: [],
            currentImageIndex: 0,
            templates: JSON.parse(localStorage.getItem('memeTemplates')) || [],
            selectedCats: new Set(),
            lastSelectedCatIndex: null,
            gridSize: 4,
            searchQuery: '',
            catImages: [],
            previewView: 'slider',
            isLoading: false
        };
        
        // Элементы DOM
        const canvas = document.getElementById('meme-canvas');
        const ctx = canvas.getContext('2d');
        let debounceTimer;
        
        // Инициализация
        initTemplates();
        setupInfiniteScroll();
        initCatLibrary();
        setupEventListeners();
        fetchCatsFromApi(24);
        updateUI();
        drawMeme();
        
        // Инициализация шаблонов
        function initTemplates() {
            const templatesGrid = document.getElementById('templates-grid');
            const noTemplatesMessage = document.getElementById('no-templates-message');
            
            if (state.templates.length === 0) {
                templatesGrid.classList.add('hidden');
                noTemplatesMessage.classList.remove('hidden');
            } else {
                templatesGrid.classList.remove('hidden');
                noTemplatesMessage.classList.add('hidden');
                renderTemplates();
            }
        }
        
        // Загрузка данных из API
        async function fetchCatsFromApi(count = 24, append = true) {
            if (state.isLoading) return;
            
            state.isLoading = true;
            const sentinel = document.getElementById('scroll-sentinel');
            if (sentinel) {
                sentinel.innerHTML = '<div class="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div><span class="ml-3 text-muted-foreground text-sm">Загружаем котиков...</span>';
            }
            
            try {
                let newCats = [];
                
                // The Cat API
                if (state.currentApi === 'thecatapi') {
                    try {
                        const response = await fetch(`https://api.thecatapi.com/v1/images/search?limit=${count}&size=small&mime_types=jpg,png`);
                        if (!response.ok) throw new Error('Ошибка TheCatAPI');
                        const data = await response.json();
                        
                        newCats = data.map(cat => ({
                            url: cat.url,
                            tags: [],
                            id: cat.id,
                            source: 'thecatapi'
                        }));
                    } catch (error) {
                        console.warn('The Cat API недоступен, используем запасной вариант');
                        newCats = generateFallbackCats(count);
                    }
                } 
                // CATAAS API
                else {
                    try {
                        const limit = count;
                        const skip = append ? state.catImages.length : 0;
                        const tags = state.searchQuery ? `&tags=${encodeURIComponent(state.searchQuery)}` : '';
                        const apiUrl = `https://cataas.com/api/cats?limit=${limit}&skip=${skip}${tags}`;
                        
                        const response = await fetch(apiUrl);
                        if (!response.ok) throw new Error(`Ошибка CATAAS: ${response.status}`);
                        
                        const data = await response.json();
                        
                        newCats = data
                            .filter(cat => cat && (cat._id || cat.id))
                            .map(cat => {
                                const catId = cat._id || cat.id;
                                return {
                                    url: `https://cataas.com/cat/${catId}?width=400&height=400&fit=cover`,
                                    tags: cat.tags || [],
                                    id: catId,
                                    source: 'cataas'
                                };
                            });
                    } catch (error) {
                        console.warn('CATAAS недоступен, используем запасной вариант');
                        newCats = generateFallbackCats(count);
                    }
                }
                
                // Сохраняем результат
                if (!append) {
                    state.catImages = newCats;
                } else {
                    const existingIds = new Set(state.catImages.map(cat => cat.id));
                    const uniqueNewCats = newCats.filter(cat => !existingIds.has(cat.id));
                    state.catImages = [...state.catImages, ...uniqueNewCats];
                }
                
                initCatLibrary();
                
            } catch (error) {
                console.error("Критическая ошибка загрузки:", error);
                showNotification('Не удалось загрузить котиков. Попробуйте позже.', 'error');
            } finally {
                state.isLoading = false;
                if (sentinel) {
                    sentinel.innerHTML = '';
                }
            }
        }
        
        // Резервный источник
        function generateFallbackCats(count) {
            const fallbackImages = [];
            for (let i = 1; i <= count; i++) {
                const width = 400;
                const height = 400;
                fallbackImages.push({
                    url: `https://cataas.com/cat?width=${width}&height=${height}&random=${Date.now() + i}`,
                    tags: ['cute', 'fallback'],
                    id: `fallback-${Date.now()}-${i}`,
                    source: 'fallback'
                });
            }
            return fallbackImages;
        }
        
        // Настройка бесконечного скролла
        function setupInfiniteScroll() {
            const sentinel = document.getElementById('scroll-sentinel');
            if (!sentinel) return;
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && !state.isLoading) {
                        fetchCatsFromApi(12);
                    }
                });
            }, {
                root: null,
                rootMargin: '200px',
                threshold: 0.1
            });
            
            observer.observe(sentinel);
        }
        
        // Инициализация библиотеки котов
        function initCatLibrary() {
            const catsGrid = document.getElementById('cats-grid');
            if (!catsGrid) return;
            
            catsGrid.innerHTML = '';
            
            const query = state.searchQuery.toLowerCase();
            
            state.catImages.forEach((catObj, index) => {
                // Фильтрация для The Cat API
                if (state.currentApi === 'thecatapi' && query) {
                    const catName = `Котик ${index + 1}`;
                    if (!catName.toLowerCase().includes(query)) return;
                }
                // Фильтрация для CATAAS (по тегам)
                else if (state.currentApi === 'cataas' && query) {
                    const hasTag = catObj.tags.some(tag => 
                        tag.toLowerCase().includes(query)
                    );
                    if (!hasTag) return;
                }
                
                const catItem = document.createElement('div');
                catItem.className = 'cat-grid-item rounded-lg overflow-hidden border border-input bg-background relative group';
                catItem.dataset.index = index;
                
                // Контейнер для изображения
                const imgContainer = document.createElement('div');
                imgContainer.className = 'relative aspect-square overflow-hidden bg-muted';
                
                const img = document.createElement('img');
                img.src = catObj.url;
                img.alt = `Котик ${index + 1}`;
                img.loading = 'lazy';
                img.className = 'w-full h-full object-cover transition-transform duration-300 hover:scale-110';
                
                // Индикатор выбора
                const selectionIndicator = document.createElement('div');
                selectionIndicator.className = `absolute top-2 right-2 w-6 h-6 rounded-full bg-primary border border-input flex items-center justify-center ${state.selectedCats.has(index) ? '' : 'hidden'}`;
                selectionIndicator.innerHTML = '<i class="fas fa-check text-white text-xs"></i>';
                
                imgContainer.appendChild(img);
                imgContainer.appendChild(selectionIndicator);
                catItem.appendChild(imgContainer);
                
                // Подпись с тегами
                const caption = document.createElement('div');
                caption.className = 'p-3';
                
                if (catObj.tags && catObj.tags.length > 0) {
                    caption.innerHTML = `
                        <p class="text-xs text-muted-foreground truncate">
                            <i class="fas fa-tag mr-1"></i> ${catObj.tags.slice(0, 3).join(', ')}
                        </p>
                    `;
                } else {
                    caption.innerHTML = `
                        <p class="text-sm font-medium truncate">Котик ${index + 1}</p>
                    `;
                }
                
                catItem.appendChild(caption);
                
                // Обработчик выбора
                catItem.addEventListener('click', (e) => handleCatSelection(e, index));
                catsGrid.appendChild(catItem);
            });
            
            updateCatSelectionUI();
            updateGridLayout(state.gridSize);
        }
        
        // Обновление размера сетки
        function updateGridSizeFromSlider() {
            const slider = document.getElementById('grid-size-slider');
            if (!slider) return;
            
            const value = parseInt(slider.value);
            const min = 2;
            const max = 6;
            const percentage = ((value - min) / (max - min)) * 100;
            
            document.getElementById('grid-size-value').textContent = value;
            const track = document.getElementById('grid-size-track');
            if (track) track.style.width = `${percentage}%`;
            
            state.gridSize = value;
            updateGridLayout(value);
        }
        
        // Обновление сетки
        function updateGridLayout(gridSize) {
            const catsGrid = document.getElementById('cats-grid');
            if (!catsGrid) return;
            
            // Очищаем все grid классы
            catsGrid.className = 'grid gap-4 mt-8';
            
            // Добавляем нужный класс
            catsGrid.classList.add(`grid-cols-${gridSize}`);
        }
        
        // Обработка выбора котика
        function handleCatSelection(e, index) {
            const isShiftPressed = e.shiftKey;
            
            if (isShiftPressed && state.lastSelectedCatIndex !== null) {
                const start = Math.min(state.lastSelectedCatIndex, index);
                const end = Math.max(state.lastSelectedCatIndex, index);
                
                for (let i = start; i <= end; i++) {
                    state.selectedCats.add(i);
                }
            } else {
                if (state.selectedCats.has(index)) {
                    state.selectedCats.delete(index);
                } else {
                    state.selectedCats.add(index);
                }
                state.lastSelectedCatIndex = index;
            }
            
            updateCatSelectionUI();
        }
        
        // Обновление UI выбора котов
        function updateCatSelectionUI() {
            const selectedCountEl = document.getElementById('selected-count');
            if (selectedCountEl) {
                selectedCountEl.textContent = state.selectedCats.size;
            }
            
            document.querySelectorAll('.cat-grid-item').forEach((item, index) => {
                const indicator = item.querySelector('.absolute.top-2.right-2');
                if (state.selectedCats.has(index)) {
                    item.classList.add('selected');
                    if (indicator) indicator.classList.remove('hidden');
                } else {
                    item.classList.remove('selected');
                    if (indicator) indicator.classList.add('hidden');
                }
            });
        }
        
        // Настройка обработчиков событий
        function setupEventListeners() {
            // Переключение вкладок
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tabId = btn.id.replace('tab-', '');
                    switchTab(tabId);
                });
            });
            
            // Переключение источников изображения
            document.querySelectorAll('.source-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const sourceId = btn.id.replace('source-', '');
                    switchSource(sourceId);
                });
            });
            
            // Выбор API
            const apiSelect = document.getElementById('api-source');
            if (apiSelect) {
                apiSelect.addEventListener('change', (e) => {
                    state.currentApi = e.target.value;
                    state.catImages = [];
                    state.searchQuery = '';
                    const searchInput = document.getElementById('cat-search');
                    if (searchInput) searchInput.value = '';
                    
                    if (state.currentApi === 'cataas') {
                        searchInput.placeholder = "Поиск по тегам (напр. orange, sleep)...";
                    } else {
                        searchInput.placeholder = "Поиск...";
                    }
                    
                    fetchCatsFromApi(24, false);
                });
            }
            
            // Поиск котиков
            const searchInput = document.getElementById('cat-search');
            if (searchInput) {
                let searchTimeout;
                searchInput.addEventListener('input', (e) => {
                    state.searchQuery = e.target.value.trim();
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        fetchCatsFromApi(24, false);
                    }, 500);
                });
            }
            
            // Кнопки искажения
            document.querySelectorAll('.distort-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.distort-btn').forEach(b => {
                        b.setAttribute('data-active', 'false');
                    });
                    btn.setAttribute('data-active', 'true');
                    handleSettingsChange();
                });
            });
            
            // Слайдер размера сетки
            const gridSizeSlider = document.getElementById('grid-size-slider');
            if (gridSizeSlider) {
                gridSizeSlider.addEventListener('input', updateGridSizeFromSlider);
            }
            
            // Переключение режима просмотра
            document.getElementById('view-slider').addEventListener('click', () => switchPreviewView('slider'));
            document.getElementById('view-grid').addEventListener('click', () => switchPreviewView('grid'));
            
            // Загрузка файлов
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            const browseBtn = document.getElementById('browse-btn');
            
            if (browseBtn) browseBtn.addEventListener('click', () => fileInput.click());
            if (fileInput) fileInput.addEventListener('change', handleFileSelect);
            
            if (dropZone) {
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('border-primary');
                });
                
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('border-primary');
                });
                
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('border-primary');
                    if (e.dataTransfer.files.length) {
                        handleFiles(e.dataTransfer.files);
                    }
                });
            }
            
            // Элементы управления
            document.getElementById('stretch-x').addEventListener('input', updateStretchX);
            document.getElementById('stretch-y').addEventListener('input', updateStretchY);
            document.getElementById('red-filter').addEventListener('input', updateRedFilter);
            
            // Тексты и формат с немедленным обновлением
            document.getElementById('top-text').addEventListener('input', handleSettingsChange);
            document.getElementById('bottom-text').addEventListener('input', handleSettingsChange);
            document.getElementById('image-format').addEventListener('change', handleFormatChange);
            
            // Кнопки действий
            document.getElementById('download-meme').addEventListener('click', downloadAllMemes);
            document.getElementById('reset-all').addEventListener('click', resetAll);
            document.getElementById('save-template').addEventListener('click', saveTemplate);
            document.getElementById('apply-to-all').addEventListener('click', applyToAllImages);
            document.getElementById('clear-batch').addEventListener('click', clearBatch);
            
            // Навигация слайдера
            document.getElementById('prev-slide').addEventListener('click', prevSlide);
            document.getElementById('next-slide').addEventListener('click', nextSlide);
            
            // Библиотека котов
            document.getElementById('goto-library-btn').addEventListener('click', () => switchTab('cats'));
            document.getElementById('select-all-cats').addEventListener('click', selectAllCats);
            document.getElementById('clear-selection-cats').addEventListener('click', clearSelectionCats);
            document.getElementById('use-selected-in-meme').addEventListener('click', useSelectedCatsInMeme);
            document.getElementById('download-selected-cats').addEventListener('click', downloadSelectedCats);
            document.getElementById('goto-meme-from-cats').addEventListener('click', () => switchTab('meme'));
            document.getElementById('goto-meme-from-templates').addEventListener('click', () => switchTab('meme'));
        }
        
        // Обработка изменений настроек
        function handleSettingsChange() {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                updateAllPreviews();
            }, 100);
        }
        
        // Обработка изменения формата
        function handleFormatChange() {
            clearTimeout(debounceTimer);
            updateAllPreviews();
        }
        
        // Обновление всех превью
        function updateAllPreviews() {
            // Основной превью
            drawMeme();
            
            // Сетка
            if (state.previewView === 'grid') {
                updateGridView();
            }
            
            // Все слайды
            if (state.images.length > 1) {
                const slideCanvases = document.querySelectorAll('.meme-slide-canvas');
                slideCanvases.forEach((canvas, index) => {
                    const ctx = canvas.getContext('2d');
                    if (state.images[index] && index !== state.currentImageIndex) {
                        drawMemeOnCanvas(ctx, state.images[index].image, index);
                    }
                });
            }
        }
        
        // Переключение режима просмотра
        function switchPreviewView(view) {
            state.previewView = view;
            
            document.querySelectorAll('.view-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });
            
            if (view === 'slider') {
                document.getElementById('slider-view').classList.remove('hidden');
                document.getElementById('grid-view').classList.add('hidden');
                document.getElementById('preview-dots').classList.remove('hidden');
            } else {
                document.getElementById('slider-view').classList.add('hidden');
                document.getElementById('grid-view').classList.remove('hidden');
                document.getElementById('preview-dots').classList.add('hidden');
                updateGridView();
            }
        }
        
        // Обновление сетки предпросмотра
        function updateGridView() {
            const gridContainer = document.getElementById('grid-container');
            if (!gridContainer) return;
            
            gridContainer.innerHTML = '';
            
            if (state.images.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'col-span-full text-center py-12';
                emptyMessage.innerHTML = `
                    <i class="fas fa-image text-5xl text-muted-foreground mb-4"></i>
                    <h3 class="text-xl font-medium mb-2">Нет изображений для отображения</h3>
                    <p class="text-muted-foreground">Загрузите изображения или выберите их из библиотеки</p>
                `;
                gridContainer.appendChild(emptyMessage);
                return;
            }
            
            state.images.forEach((imgData, index) => {
                const gridItem = document.createElement('div');
                gridItem.className = 'preview-grid-item';
                
                const canvas = document.createElement('canvas');
                canvas.className = 'preview-grid-canvas';
                canvas.width = 300;
                canvas.height = 200;
                
                // Немедленная отрисовка
                const ctx = canvas.getContext('2d');
                drawMemeOnCanvas(ctx, imgData.image, index);
                
                const info = document.createElement('div');
                info.className = 'preview-grid-info';
                info.innerHTML = `
                    <p class="font-medium truncate">${imgData.name}</p>
                    <p class="text-xs text-muted-foreground mt-1">Изображение ${index + 1}</p>
                `;
                
                gridItem.appendChild(canvas);
                gridItem.appendChild(info);
                gridContainer.appendChild(gridItem);
            });
        }
        
        // Переключение вкладок
        function switchTab(tabId) {
            state.currentTab = tabId;
            
            document.querySelectorAll('.tab-btn').forEach(btn => {
                const btnTabId = btn.id.replace('tab-', '');
                btn.setAttribute('data-active', btnTabId === tabId ? 'true' : 'false');
            });
            
            document.querySelectorAll('.tab-content').forEach(content => {
                const contentTabId = content.id.replace('content-', '');
                if (contentTabId === tabId) {
                    content.classList.remove('hidden');
                    content.classList.add('active', 'animate-fadeIn');
                } else {
                    content.classList.add('hidden');
                    content.classList.remove('active', 'animate-fadeIn');
                }
            });
            
            if (tabId === 'cats') {
                updateCatSelectionUI();
            }
        }
        
        // Переключение источника изображения
        function switchSource(sourceId) {
            document.querySelectorAll('.source-btn').forEach(btn => {
                const btnSourceId = btn.id.replace('source-', '');
                btn.setAttribute('data-active', btnSourceId === sourceId ? 'true' : 'false');
            });
            
            if (sourceId === 'upload') {
                document.getElementById('upload-section').classList.remove('hidden');
                document.getElementById('library-section').classList.add('hidden');
            } else {
                document.getElementById('upload-section').classList.add('hidden');
                document.getElementById('library-section').classList.remove('hidden');
            }
        }
        
        // Обработка выбора файлов
        function handleFileSelect(e) {
            handleFiles(e.target.files);
        }
        
        function handleFiles(files) {
            if (!files.length) return;
            
            const fileList = document.getElementById('file-list');
            fileList.innerHTML = '';
            
            Array.from(files).forEach((file, index) => {
                if (!file.type.startsWith('image/')) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        state.images.push({
                            id: Date.now() + index,
                            name: file.name,
                            file: file,
                            image: img,
                            dataUrl: e.target.result
                        });
                        
                        const fileItem = document.createElement('div');
                        fileItem.className = 'flex items-center justify-between p-2 rounded bg-muted';
                        fileItem.innerHTML = `
                            <div class="flex items-center">
                                <i class="fas fa-image text-muted-foreground mr-3"></i>
                                <span class="text-sm truncate max-w-[150px]">${file.name}</span>
                            </div>
                            <button class="remove-file-btn text-xs p-1 rounded hover:bg-destructive hover:text-destructive-foreground" data-id="${state.images.length - 1}">
                                <i class="fas fa-times"></i>
                            </button>
                        `;
                        fileList.appendChild(fileItem);
                        
                        fileItem.querySelector('.remove-file-btn').addEventListener('click', function() {
                            const id = parseInt(this.getAttribute('data-id'));
                            removeImage(id);
                            fileItem.remove();
                        });
                        
                        if (state.images.length === 1) {
                            state.currentImageIndex = 0;
                            updatePreviewSlider();
                            drawMeme();
                        }
                        
                        updateUI();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // Удаление изображения
        function removeImage(id) {
            if (state.images[id]) {
                revokeImageUrl(state.images[id].dataUrl);
            }
            
            state.images.splice(id, 1);
            
            document.querySelectorAll('.remove-file-btn').forEach((btn, index) => {
                btn.setAttribute('data-id', index);
            });
            
            if (state.images.length === 0) {
                state.currentImageIndex = 0;
            } else if (state.currentImageIndex >= state.images.length) {
                state.currentImageIndex = state.images.length - 1;
            }
            
            updatePreviewSlider();
            updateUI();
            
            if (state.images.length > 0) {
                drawMeme();
            }
        }
        
        // Обновление слайдера предпросмотра
        function updatePreviewSlider() {
            const slidesContainer = document.getElementById('slides-container');
            const noImagesMessage = document.getElementById('no-images-message');
            const prevBtn = document.getElementById('prev-slide');
            const nextBtn = document.getElementById('next-slide');
            const applyToAllBtn = document.getElementById('apply-to-all');
            const batchStatus = document.getElementById('batch-status');
            const batchCount = document.getElementById('batch-count');
            const previewDots = document.getElementById('preview-dots');
            
            if (state.images.length === 0) {
                slidesContainer.innerHTML = `
                    <div class="preview-slide min-w-full flex items-center justify-center p-4">
                        <canvas id="meme-canvas" class="max-w-full max-h-[350px] bg-background rounded-lg shadow-lg"></canvas>
                    </div>
                `;
                slidesContainer.classList.add('hidden');
                if (noImagesMessage) noImagesMessage.classList.remove('hidden');
                if (prevBtn) prevBtn.classList.add('hidden');
                if (nextBtn) nextBtn.classList.add('hidden');
                if (applyToAllBtn) applyToAllBtn.classList.add('hidden');
                if (batchStatus) batchStatus.classList.add('hidden');
                if (previewDots) previewDots.innerHTML = '';
                
                document.getElementById('current-slide').textContent = '0';
                document.getElementById('total-slides').textContent = '0';
                document.getElementById('current-image-name').textContent = 'Нет изображения';
                
                return;
            }
            
            slidesContainer.classList.remove('hidden');
            if (noImagesMessage) noImagesMessage.classList.add('hidden');
            
            slidesContainer.innerHTML = '';
            
            state.images.forEach((imgData, index) => {
                const slide = document.createElement('div');
                slide.className = 'preview-slide min-w-full flex items-center justify-center p-4';
                slide.dataset.index = index;
                
                const slideCanvas = document.createElement('canvas');
                slideCanvas.className = 'meme-slide-canvas max-w-full max-h-[350px] bg-background rounded-lg shadow-lg';
                slideCanvas.dataset.index = index;
                slideCanvas.width = 600;
                slideCanvas.height = 400;
                
                slide.appendChild(slideCanvas);
                slidesContainer.appendChild(slide);
            });
            
            document.getElementById('current-slide').textContent = state.currentImageIndex + 1;
            document.getElementById('total-slides').textContent = state.images.length;
            document.getElementById('current-image-name').textContent = state.images[state.currentImageIndex].name;
            
            if (prevBtn) prevBtn.classList.toggle('hidden', state.images.length <= 1);
            if (nextBtn) nextBtn.classList.toggle('hidden', state.images.length <= 1);
            if (applyToAllBtn) applyToAllBtn.classList.toggle('hidden', state.images.length <= 1);
            
            if (batchStatus) {
                if (state.images.length > 1) {
                    batchStatus.classList.remove('hidden');
                    batchCount.textContent = `Обрабатывается ${state.images.length} изображений`;
                } else {
                    batchStatus.classList.add('hidden');
                }
            }
            
            if (previewDots) {
                previewDots.innerHTML = '';
                for (let i = 0; i < state.images.length; i++) {
                    const dot = document.createElement('div');
                    dot.className = `preview-dot ${i === state.currentImageIndex ? 'active' : ''}`;
                    dot.dataset.index = i;
                    dot.addEventListener('click', () => {
                        state.currentImageIndex = i;
                        updatePreviewSlider();
                        drawMeme();
                    });
                    previewDots.appendChild(dot);
                }
            }
            
            slidesContainer.style.transform = `translateX(-${state.currentImageIndex * 100}%)`;
            drawMeme();
            
            if (state.previewView === 'grid') {
                updateGridView();
            }
        }
        
        // Навигация слайдов
        function prevSlide() {
            if (state.currentImageIndex > 0) {
                state.currentImageIndex--;
                updatePreviewSlider();
                drawMeme();
            }
        }
        
        function nextSlide() {
            if (state.currentImageIndex < state.images.length - 1) {
                state.currentImageIndex++;
                updatePreviewSlider();
                drawMeme();
            }
        }
        
        // Обновление растяжения
        function updateStretchX() {
            const slider = document.getElementById('stretch-x');
            const value = parseFloat(slider.value);
            const percentage = ((value - 0.5) / 1.5) * 100;
            
            document.getElementById('stretch-x-value').textContent = value.toFixed(1);
            document.getElementById('stretch-x-track').style.width = `${percentage}%`;
            
            handleSettingsChange();
        }
        
        function updateStretchY() {
            const slider = document.getElementById('stretch-y');
            const value = parseFloat(slider.value);
            const percentage = ((value - 0.5) / 1.5) * 100;
            
            document.getElementById('stretch-y-value').textContent = value.toFixed(1);
            document.getElementById('stretch-y-track').style.width = `${percentage}%`;
            
            handleSettingsChange();
        }
        
        function updateRedFilter() {
            const slider = document.getElementById('red-filter');
            const value = parseInt(slider.value);
            
            document.getElementById('red-filter-value').textContent = `${value}%`;
            document.getElementById('red-filter-track').style.width = `${value}%`;
            
            handleSettingsChange();
        }
        
        // Основная функция рисования мема
        function drawMeme() {
            if (state.images.length === 0 || !state.images[state.currentImageIndex]) {
                const mainCanvas = document.getElementById('meme-canvas');
                const ctx = mainCanvas.getContext('2d');
                ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--background') || '#ffffff';
                ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
                
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted-foreground') || '#6b7280';
                ctx.font = '16px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Нет изображения для отображения', mainCanvas.width / 2, mainCanvas.height / 2);
                return;
            }
            
            const slideCanvases = document.querySelectorAll('.meme-slide-canvas');
            const currentSlideCanvas = slideCanvases[state.currentImageIndex] || 
                                    document.getElementById('meme-canvas');
            
            const ctx = currentSlideCanvas.getContext('2d');
            const currentImage = state.images[state.currentImageIndex].image;
            
            const format = document.getElementById('image-format').value;
            const stretchX = parseFloat(document.getElementById('stretch-x').value);
            const stretchY = parseFloat(document.getElementById('stretch-y').value);
            const redFilter = parseInt(document.getElementById('red-filter').value);
            const distortHorizontal = document.getElementById('distort-horizontal').getAttribute('data-active') === 'true';
            const topText = document.getElementById('top-text').value;
            const bottomText = document.getElementById('bottom-text').value;
            
            // Определяем размеры холста
            let canvasWidth = 600;
            let canvasHeight = 400;
            const aspectRatio = currentImage.width / currentImage.height;
            
            switch(format) {
                case 'square':
                    canvasWidth = 500;
                    canvasHeight = 500;
                    break;
                case 'standard':
                    canvasHeight = canvasWidth * (3/4);
                    break;
                case 'classic':
                    canvasHeight = canvasWidth * (2/3);
                    break;
                case 'wide':
                    canvasHeight = canvasWidth * (9/16);
                    break;
                case 'cinematic':
                    canvasHeight = canvasWidth * (9/21);
                    break;
                case 'insta-portrait':
                    canvasHeight = canvasWidth * (5/4);
                    break;
                case 'portrait':
                    canvasWidth = canvasHeight * (9/16);
                    break;
                default:
                    if (aspectRatio > 1) {
                        canvasHeight = canvasWidth / aspectRatio;
                    } else {
                        canvasWidth = canvasHeight * aspectRatio;
                    }
            }
            
            currentSlideCanvas.width = canvasWidth;
            currentSlideCanvas.height = canvasHeight;
            
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            let drawWidth = canvasWidth * stretchX;
            let drawHeight = canvasHeight * stretchY;
            
            if (distortHorizontal) {
                drawWidth = canvasWidth * (stretchX * 1.5);
            } else {
                drawHeight = canvasHeight * (stretchY * 1.5);
            }
            
            const x = (canvasWidth - drawWidth) / 2;
            const y = (canvasHeight - drawHeight) / 2;
            
            ctx.drawImage(currentImage, x, y, drawWidth, drawHeight);
            
            if (redFilter > 0) {
                const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, data[i] + redFilter * 2.55);
                    data[i + 1] = Math.max(0, data[i + 1] - redFilter * 1.2);
                    data[i + 2] = Math.max(0, data[i + 2] - redFilter * 1.2);
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            if (topText) addTextToCanvas(ctx, topText, 'top', canvasWidth, canvasHeight);
            if (bottomText) addTextToCanvas(ctx, bottomText, 'bottom', canvasWidth, canvasHeight);
        }
        
        // Функция рисования мема на любом canvas
        function drawMemeOnCanvas(ctx, currentImage, imageIndex) {
            const format = document.getElementById('image-format').value;
            const stretchX = parseFloat(document.getElementById('stretch-x').value);
            const stretchY = parseFloat(document.getElementById('stretch-y').value);
            const redFilter = parseInt(document.getElementById('red-filter').value);
            const distortHorizontal = document.getElementById('distort-horizontal').getAttribute('data-active') === 'true';
            const topText = document.getElementById('top-text').value;
            const bottomText = document.getElementById('bottom-text').value;
            
            let canvasWidth = ctx.canvas.width || 300;
            let canvasHeight = ctx.canvas.height || 200;
            const aspectRatio = currentImage.width / currentImage.height;
            
            // Корректируем пропорции по формату
            let targetWidth = canvasWidth;
            let targetHeight = canvasHeight;
            
            switch(format) {
                case 'square':
                    if (targetWidth > targetHeight) {
                        targetWidth = targetHeight;
                    } else {
                        targetHeight = targetWidth;
                    }
                    break;
                case 'standard':
                    targetHeight = targetWidth * (3/4);
                    break;
                case 'classic':
                    targetHeight = targetWidth * (2/3);
                    break;
                case 'wide':
                    targetHeight = targetWidth * (9/16);
                    break;
                case 'cinematic':
                    targetHeight = targetWidth * (9/21);
                    break;
                case 'insta-portrait':
                    targetHeight = targetWidth * (5/4);
                    break;
                case 'portrait':
                    targetWidth = targetHeight * (9/16);
                    break;
                default:
                    const currentAspect = targetWidth / targetHeight;
                    if (aspectRatio > currentAspect) {
                        targetHeight = targetWidth / aspectRatio;
                    } else {
                        targetWidth = targetHeight * aspectRatio;
                    }
            }
            
            if (ctx.canvas.width !== targetWidth || ctx.canvas.height !== targetHeight) {
                ctx.canvas.width = targetWidth;
                ctx.canvas.height = targetHeight;
                canvasWidth = targetWidth;
                canvasHeight = targetHeight;
            }
            
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            let drawWidth = canvasWidth * stretchX;
            let drawHeight = canvasHeight * stretchY;
            
            if (distortHorizontal) {
                drawWidth = canvasWidth * (stretchX * 1.5);
            } else {
                drawHeight = canvasHeight * (stretchY * 1.5);
            }
            
            const x = (canvasWidth - drawWidth) / 2;
            const y = (canvasHeight - drawHeight) / 2;
            
            ctx.drawImage(currentImage, x, y, drawWidth, drawHeight);
            
            if (redFilter > 0) {
                const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, data[i] + redFilter * 2.55);
                    data[i + 1] = Math.max(0, data[i + 1] - redFilter * 1.2);
                    data[i + 2] = Math.max(0, data[i + 2] - redFilter * 1.2);
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            if (topText) addTextToCanvas(ctx, topText, 'top', canvasWidth, canvasHeight);
            if (bottomText) addTextToCanvas(ctx, bottomText, 'bottom', canvasWidth, canvasHeight);
        }
        
        // Функция добавления текста
        function addTextToCanvas(ctx, text, position, canvasWidth, canvasHeight) {
            const lines = text.split('\n');
            const fontSize = Math.min(40, canvasWidth / 15);
            const lineHeight = fontSize * 1.2;
            const maxWidth = canvasWidth * 0.9;
            
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = Math.max(2, fontSize / 10);
            ctx.textAlign = 'center';
            ctx.font = `bold ${fontSize}px Impact, Arial Black, sans-serif`;
            
            const totalHeight = lines.length * lineHeight;
            let y;
            
            if (position === 'top') {
                y = 20 + lineHeight;
            } else {
                y = canvasHeight - 20 - totalHeight + lineHeight;
            }
            
            lines.forEach((line, index) => {
                const currentY = y + (index * lineHeight);
                let currentLine = line;
                const metrics = ctx.measureText(currentLine);
                
                if (metrics.width > maxWidth && line.includes(' ')) {
                    const words = line.split(' ');
                    const mid = Math.floor(words.length / 2);
                    const line1 = words.slice(0, mid).join(' ');
                    const line2 = words.slice(mid).join(' ');
                    
                    ctx.strokeText(line1, canvasWidth / 2, currentY - lineHeight/2);
                    ctx.fillText(line1, canvasWidth / 2, currentY - lineHeight/2);
                    ctx.strokeText(line2, canvasWidth / 2, currentY + lineHeight/2);
                    ctx.fillText(line2, canvasWidth / 2, currentY + lineHeight/2);
                } else {
                    ctx.strokeText(currentLine, canvasWidth / 2, currentY);
                    ctx.fillText(currentLine, canvasWidth / 2, currentY);
                }
            });
        }
        
        // Обновление UI
        function updateUI() {
            const batchStatus = document.getElementById('batch-status');
            const batchCount = document.getElementById('batch-count');
            
            if (batchStatus && batchCount) {
                if (state.images.length > 1) {
                    batchStatus.classList.remove('hidden');
                    batchCount.textContent = `Обрабатывается ${state.images.length} изображений`;
                } else {
                    batchStatus.classList.add('hidden');
                }
            }
        }
        
        // Скачивание всех мемов
        async function downloadAllMemes() {
            if (state.images.length === 0) {
                alert('Нет изображений для скачивания');
                return;
            }
            
            showNotification('Начинаю скачивание...', 'info');
            
            try {
                for (let i = 0; i < state.images.length; i++) {
                    const link = document.createElement('a');
                    link.download = `meme-${i + 1}-${Date.now()}.png`;
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = 600;
                    tempCanvas.height = 400;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    drawMemeOnCanvas(tempCtx, state.images[i].image, i);
                    
                    link.href = tempCanvas.toDataURL('image/png');
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    if (i < state.images.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                }
                
                showNotification(`Скачано ${state.images.length} изображений`, 'success');
                
            } catch (error) {
                console.error('Ошибка скачивания:', error);
                showNotification('Ошибка при скачивании', 'error');
            }
        }
        
        // Сброс всех настроек
        function resetAll() {
            document.getElementById('stretch-x').value = 1;
            document.getElementById('stretch-y').value = 1;
            document.getElementById('red-filter').value = 0;
            document.getElementById('top-text').value = '';
            document.getElementById('bottom-text').value = '';
            document.getElementById('image-format').value = 'original';
            
            document.querySelectorAll('.distort-btn').forEach(btn => {
                btn.setAttribute('data-active', btn.id === 'distort-horizontal' ? 'true' : 'false');
            });
            
            updateStretchX();
            updateStretchY();
            updateRedFilter();
            
            handleSettingsChange();
        }
        
        // Сохранение шаблона
        function saveTemplate() {
            const nameInput = document.getElementById('template-name');
            const name = nameInput.value.trim();
            
            if (!name) {
                alert('Введите название шаблона');
                return;
            }
            
            const template = {
                id: Date.now(),
                name: name,
                date: new Date().toLocaleDateString(),
                settings: {
                    stretchX: parseFloat(document.getElementById('stretch-x').value),
                    stretchY: parseFloat(document.getElementById('stretch-y').value),
                    redFilter: parseInt(document.getElementById('red-filter').value),
                    distortHorizontal: document.getElementById('distort-horizontal').getAttribute('data-active') === 'true',
                    topText: document.getElementById('top-text').value,
                    bottomText: document.getElementById('bottom-text').value,
                    imageFormat: document.getElementById('image-format').value
                }
            };
            
            state.templates.push(template);
            localStorage.setItem('memeTemplates', JSON.stringify(state.templates));
            nameInput.value = '';
            initTemplates();
            showNotification('Шаблон сохранен!', 'success');
        }
        
        // Рендер шаблонов
        function renderTemplates() {
            const templatesGrid = document.getElementById('templates-grid');
            templatesGrid.innerHTML = '';
            
            state.templates.forEach(template => {
                const templateItem = document.createElement('div');
                templateItem.className = 'template-item bg-card border border-border rounded-lg p-4 hover:shadow-md transition-all';
                
                templateItem.innerHTML = `
                    <div class="flex justify-between items-start mb-3">
                        <div>
                            <h4 class="font-semibold">${template.name}</h4>
                            <p class="text-sm text-muted-foreground">Создан: ${template.date}</p>
                        </div>
                        <button class="apply-template-btn p-2 rounded hover:bg-accent" data-id="${template.id}">
                            <i class="fas fa-play text-primary"></i>
                        </button>
                    </div>
                    <div class="text-sm space-y-1">
                        <p class="truncate"><span class="text-muted-foreground">Верхний текст:</span> ${template.settings.topText || 'нет'}</p>
                        <p class="truncate"><span class="text-muted-foreground">Нижний текст:</span> ${template.settings.bottomText || 'нет'}</p>
                        <p><span class="text-muted-foreground">Формат:</span> ${getFormatName(template.settings.imageFormat)}</p>
                    </div>
                    <div class="mt-4 pt-3 border-t border-border flex justify-between">
                        <button class="delete-template-btn text-xs px-3 py-1 rounded border border-input hover:bg-destructive hover:text-destructive-foreground" data-id="${template.id}">
                            Удалить
                        </button>
                        <button class="edit-template-btn text-xs px-3 py-1 rounded border border-input hover:bg-accent" data-id="${template.id}">
                            Применить
                        </button>
                    </div>
                `;
                
                templatesGrid.appendChild(templateItem);
            });
            
            document.querySelectorAll('.apply-template-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const id = parseInt(this.getAttribute('data-id'));
                    applyTemplate(id);
                });
            });
            
            document.querySelectorAll('.delete-template-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const id = parseInt(this.getAttribute('data-id'));
                    deleteTemplate(id);
                });
            });
            
            document.querySelectorAll('.edit-template-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const id = parseInt(this.getAttribute('data-id'));
                    applyTemplate(id);
                    switchTab('meme');
                });
            });
        }
        
        // Получение читаемого названия формата
        function getFormatName(format) {
            switch(format) {
                case 'original': return 'Оригинальный';
                case 'square': return 'Квадрат (1:1)';
                case 'standard': return 'Стандарт (4:3)';
                case 'classic': return 'Классика (3:2)';
                case 'cinematic': return 'Кино (21:9)';
                case 'insta-portrait': return 'Инста (4:5)';
                case 'wide': return 'Широкий (16:9)';
                case 'portrait': return 'Портрет (9:16)';
                default: return format;
            }
        }
        
        // Применение шаблона
        function applyTemplate(id) {
            const template = state.templates.find(t => t.id === id);
            if (!template) return;
            
            const settings = template.settings;
            
            document.getElementById('stretch-x').value = settings.stretchX;
            document.getElementById('stretch-y').value = settings.stretchY;
            document.getElementById('red-filter').value = settings.redFilter;
            document.getElementById('top-text').value = settings.topText;
            document.getElementById('bottom-text').value = settings.bottomText;
            document.getElementById('image-format').value = settings.imageFormat;
            
            document.querySelectorAll('.distort-btn').forEach(btn => {
                btn.setAttribute('data-active', 
                    (settings.distortHorizontal && btn.id === 'distort-horizontal') || 
                    (!settings.distortHorizontal && btn.id === 'distort-vertical') ? 'true' : 'false');
            });
            
            updateStretchX();
            updateStretchY();
            updateRedFilter();
            
            handleSettingsChange();
            showNotification(`Шаблон "${template.name}" применен!`, 'success');
        }
        
        // Удаление шаблона
        function deleteTemplate(id) {
            if (!confirm('Удалить этот шаблон?')) return;
            
            state.templates = state.templates.filter(t => t.id !== id);
            localStorage.setItem('memeTemplates', JSON.stringify(state.templates));
            initTemplates();
            showNotification('Шаблон удален', 'info');
        }
        
        // Применить настройки ко всем изображениям
        function applyToAllImages() {
            if (state.images.length <= 1) return;
            
            if (confirm(`Применить текущие настройки ко всем ${state.images.length} изображениям?`)) {
                if (state.previewView === 'slider') {
                    const slideCanvases = document.querySelectorAll('.meme-slide-canvas');
                    slideCanvases.forEach((canvas, index) => {
                        const ctx = canvas.getContext('2d');
                        if (state.images[index]) {
                            drawMemeOnCanvas(ctx, state.images[index].image, index);
                        }
                    });
                } else {
                    updateGridView();
                }
                
                showNotification('Настройки применены ко всем изображениям', 'success');
            }
        }
        
        // Очистка пакета
        function clearBatch() {
            state.images.forEach(img => {
                revokeImageUrl(img.dataUrl);
            });
            state.images = [];
            updatePreviewSlider();
            updateUI();
            drawMeme();
        }
        
        // Выбор всех котов
        function selectAllCats() {
            state.selectedCats = new Set(Array.from({length: state.catImages.length}, (_, i) => i));
            updateCatSelectionUI();
        }
        
        // Очистка выбора котов
        function clearSelectionCats() {
            state.selectedCats.clear();
            updateCatSelectionUI();
        }
        
        // Использование выбранных котов
        async function useSelectedCatsInMeme() {
            if (state.selectedCats.size === 0) {
                alert('Выберите хотя бы одно изображение из библиотеки');
                return;
            }
            
            clearBatch();
            
            const selectedIndices = Array.from(state.selectedCats);
            showNotification(`Загрузка ${selectedIndices.length} изображений...`, 'info');
            
            const loadPromises = selectedIndices.map(async (index) => {
                const catObj = state.catImages[index];
                if (!catObj) return null;
                
                try {
                    const response = await fetch(catObj.url);
                    const blob = await response.blob();
                    const objectURL = URL.createObjectURL(blob);
                    
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = function() {
                            resolve({
                                id: Date.now() + index,
                                name: `Котик ${index + 1}`,
                                image: img,
                                dataUrl: objectURL
                            });
                        };
                        img.onerror = function() {
                            resolve(null);
                        };
                        img.src = objectURL;
                    });
                } catch (error) {
                    return null;
                }
            });
            
            const loadedImages = await Promise.all(loadPromises);
            state.images = loadedImages.filter(img => img !== null);
            
            if (state.images.length > 0) {
                state.currentImageIndex = 0;
                updatePreviewSlider();
                switchTab('meme');
                switchSource('upload');
                showNotification(`Загружено ${state.images.length} изображений`, 'success');
            } else {
                showNotification('Не удалось загрузить изображения', 'error');
            }
        }
        
        // Скачивание выбранных котов
        async function downloadSelectedCats() {
            if (state.selectedCats.size === 0) {
                alert('Выберите изображения для скачивания');
                return;
            }

            showNotification('Начинаю скачивание...', 'info');

            const indices = Array.from(state.selectedCats);
            
            for (const index of indices) {
                const catObj = state.catImages[index];
                if (!catObj) continue;

                try {
                    const response = await fetch(catObj.url);
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    
                    const link = document.createElement('a');
                    link.href = url;
                    const fileName = catObj.id ? `cat-${catObj.id}.jpg` : `cat-${index + 1}.jpg`;
                    link.download = fileName;
                    
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                } catch (e) {
                    console.error("Не удалось скачать картинку", e);
                }
            }

            showNotification(`Скачивание завершено`, 'success');
        }
        
        // Очистка памяти
        function revokeImageUrl(dataUrl) {
            if (dataUrl && typeof dataUrl === 'string' && dataUrl.startsWith('blob:')) {
                URL.revokeObjectURL(dataUrl);
            }
        }
        
        // Показать уведомление
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 z-50 px-4 py-3 rounded-lg shadow-lg border max-w-sm animate-fadeIn ${
                type === 'success' ? 'bg-green-50 border-green-200 text-green-800' :
                type === 'error' ? 'bg-red-50 border-red-200 text-red-800' :
                'bg-blue-50 border-blue-200 text-blue-800'
            }`;
            
            notification.innerHTML = `
                <div class="flex items-center">
                    <i class="fas ${
                        type === 'success' ? 'fa-check-circle' :
                        type === 'error' ? 'fa-exclamation-circle' :
                        'fa-info-circle'
                    } mr-3"></i>
                    <span>${message}</span>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.add('opacity-0', 'transition-opacity', 'duration-300');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }
    });
</script>
</body>
</html>
